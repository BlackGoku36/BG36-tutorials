<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../doc.css">
    <link rel="stylesheet" href="../../../atom-one-dark.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title>BG36-Tutorials | TUT-1</title>
</head>
<body class="purple-grey">
    <div id="sidebar" class="sidebar">
        <script src="../sidebar.js"></script>
    </div>
    <div id="main">
        <script src="../../../main1.js"></script>
        <script>main("Basics");</script>
<p>In <code>Basics</code> part we will establish basics of city buildings, such as placing, moving, etc of buildings with player interaction.</p>
<hr />
<p>Table of contents:</p>
<ul>
<li><a href="docs/Game_Demo/City_Sim/Basics#Arcball-camera">Arcball Camera</a></li>
<li><a href="docs/Game_Demo/City_Sim/Basics#Buildings">Buildings</a></li>
<li><a href="docs/Game_Demo/City_Sim/Basics#Player">Player</a></li>
</ul>
<hr />
<h2 id="arcballcamera">ARCBALL CAMERA</h2>
<p>To view around our scene's environment, we will use arcball camera rotation. Now, arcball rotation is <em>rotation of an object around a point</em>. We will arcball rotate the camera when right mouse button is pressed and hold and use mouse wheel to zoom in and out.</p>
<p>To do so:</p>
<ol>
<li>Create an empty <code>CameraEmpty</code> and position it to center of world and then set parent of our camera to this empty.</li>
<li>Create new haxe trait <code>CameraController</code> and assign it to our camera, we will use this to control behavior of our camera.</li>
</ol>
<!-- tabs:start -->
<h4 id="cameracontrollerhx"><strong>CameraController.hx</strong></h4>
<pre><code class="haxe language-haxe">package arm;

import iron.Scene;
import iron.system.Input;
import iron.math.Vec4;

class CameraController extends iron.Trait {
    //Get our CameraEmpty
    var cameraEmpty = Scene.active.getEmpty("CameraEmpty").transform;
    //Get mouse
    var mouse = Input.getMouse();

    @prop
    var viewMin = 1.0;
    @prop
    var viewMax = 2.8;

    public function new() {
        super();
        notifyOnUpdate(update);
    }

    function update() {
        if(mouse.down("right")){
            // Rotate our empty on z-axis in opposite direction of our mouse-x movement.
            // Mouse movement is divided by 200 to slow the rotation.
            cameraEmpty.rotate(new Vec4(0, 0, 1), -mouse.movementX / 200);
            cameraEmpty.buildMatrix();
            cameraEmpty.rotate(object.transform.world.right(), -mouse.movementY / 200);
            cameraEmpty.buildMatrix();
        }

        if (mouse.wheelDelta != 0){
            //Add mouse wheel delta to cameraEmpty scale
            cameraEmpty.scale.add(new Vec4(mouse.wheelDelta/30, mouse.wheelDelta/30, mouse.wheelDelta/30));
            //Clamp the scale
            cameraEmpty.scale.clamp(viewMin, viewMax);
            cameraEmpty.buildMatrix();
        }
    }
}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li><code>@prop</code>, is used for variable that need configuration, if you refresh script than you can edit this variable straight from blender.</li>
<li>We get empty's transform and and set it z-axis rotation to reverse of our mouse moment on x-axis and slow it down by 200, and then <code>buildMatrix()</code>.</li>
<li>We rotate our empty again but on object's right location in world-space and with our mouse's moment on y-axis and again call <code>buildMatrix()</code>.</li>
<li>If mouse's wheel is moving, than add mouse's wheel delta to cameraEmpty's scale and slow it down by 30, thus adding zoom in and out.</li>
<li>Clamp the scale between viewMin and viewMax, so that camera can't zoom in and out more.</li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<p>You should get this:</p>
<p><img src="/../../../docassets/CBS_1.gif" alt="" title=":size=400" /></p>
<hr />
<h2 id="buildings">BUILDINGS</h2>
<p>To manage our city, we will need to spawn, move, remove, rotate our buildings.</p>
<ol>
<li><p>Create a cube <code>hs</code>(stand for house), we will use this for assets, it will do nothing else of sort.</p></li>
<li><p>Create a plane <code>bld_1</code>(we will use numbers for types), and make <code>hs</code> as child to this plane, we will use this as base, and for interaction. Set its physics as:</p>
<ul>
<li>Physics type -&gt; RigidBody</li>
<li>RigidBody Type -&gt; Passive</li>
<li>Setting -&gt; Animated</li>
<li>Collision shape -&gt; Box</li>
<li>Collision Collection -&gt; 2nd Group</li>
<li>Collision Filter mask -&gt; 2nd Group</li></ul></li>
<li><p>Set plane (ground) physics as:</p>
<ul>
<li>Physics type -&gt; RigidBody</li>
<li>RigidBody Type -&gt; Passive</li>
<li>Collision shape -&gt; Box</li></ul></li>
</ol>
<p>?&gt; Collision filter mask will make ray-cast ignore the object.</p>
<ol start="4">
<li>Create new Haxe trait <code>BuildingController</code> and assign it to scene.</li>
</ol>
<h3 id="selectingandunselecting">SELECTING AND UNSELECTING</h3>
<p>We will interact with our building by selecting, unselecting building. To do so, We will physics ray-cast to group 2(groups of buildings) and check if it hit any of our building, if it do than set selected building to this.</p>
<!-- tabs:start -->
<h4 id="buildingcontrollerhx"><strong>BuildingController.hx</strong></h4>
<pre><code class="haxe language-haxe">import armory.trait.physics.PhysicsWorld;

import iron.Scene;
import iron.math.Vec4;
import iron.math.RayCaster;
import iron.system.Input;

//Define structure of building
typedef Building = {
    name: String,
    type: Int
}

class BuildingController extends iron.Trait {
    //Declare selectedBuilding, i.e., name of building currently selected.
    public static var selectedBuilding:Building = null;
    //Whether any building is selected or not
    public static var isBuildingSelected = false;

    public function new() {
        super();
    }

    public static function raySelectBuilding() {
        //Get rigid body from raycast from group 2.
        var rigidbody = getRaycast(2).rigidbody;
        //Check if rigidbody isn't null and rigidbody's name start with "bld"
        if(rigidbody != null &amp;&amp; StringTools.startsWith(rigidbody.object.name, "bld")){
            //Set selected building to hit rigidbody name
            selectedBuilding = getBuildingFromString(rigidbody.object.name);
            isBuildingSelected = true;
        }else {
            selectedBuilding = null;
            isBuildingSelected = false;
        }
    }

    static function getRaycast(group:Int){
        var physics = PhysicsWorld.active;
        var mouse = Input.getMouse();
        var start = new Vec4();
        var end = new Vec4();
        var camera = Scene.active.getCamera("Camera");
        // Get Ray-cast direction from start to end with mouse's x, y and camera
        RayCaster.getDirection(start, end, mouse.x, mouse.y, camera);
        // cast ray from camera's location in world space to end vec and get hit result.
        var hit = physics.rayCast(camera.transform.world.getLoc(), end, group);
        var rigidbody = (hit != null) ? hit.rb : null;
        //wrap rigidbody and hit result and return it.
        return{
            rigidbody: rigidbody,
            hit: hit
        };
    }

    static function getBuildingFromString(name: String):Building {
        var building:Building = null;
        for(i in buildings){
            if (i.name == name) building = i;
        }
        return building;
    }

}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li><p>We define data structure of our building, that is its name and it type, with this it will be a lot easier to manage buildings(add, remove, etc).</p></li>
<li><p>We create <code>getBuildingFromString(*name*)</code>, we loop through all building and check if name match building's name, if so, return the building object.</p></li>
<li><p>We create <code>getRaycast(*group*)</code> specially, as we don't want to repeat this function during selecting and moving of building. This will ray-cast for specific group from camera to mouse's x/y location in world space, and get hit and rigidbody.</p></li>
<li><p>We create <code>raySelectBuilding()</code>, which will be use to ofc selected building, we will do so why using our getRaycast() and get rigidbody of hit object, if this rigidbody's name start with 'bld' then set selectedBuilding to this rigidbody name and set isBuildingSelected to true else, null and false.</p></li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<h3 id="moving">MOVING</h3>
<p>We will want to move building across ground to be able to place it wherever we like. For doing that, we will physics ray-cast to group 1 and check if it hit plane, if it do than update building position to ray's hit location every frame.</p>
<!-- tabs:start -->
<h4 id="buildingcontrollerhx-1"><strong>BuildingController.hx</strong></h4>
<pre><code class="haxe language-haxe">~
typedef Building = { ~ }
class BuildingController extends iron.Trait {
    ~
    //Should building move
    public static var buildingMove = false;

    public static function new() { ~ }
    public static function raySelectBuilding() { ~ }

    public static function moveBuilding() {
        var raycast = getRaycast(1);
        if(raycast.rigidbody != null &amp;&amp; raycast.rigidbody.object.name == "Ground") {
            //Set loc of selected building as floor of ray hit position's x, y and z as 0.4.
            Scene.active.getChild(selectedBuilding.name).transform.loc.set(Math.floor(raycast.hit.pos.x), Math.floor(raycast.hit.pos.y), 0.2);
        }
    }

    static function getRaycast(group:Int){ ~ }
    static function getBuildingFromString(name: String):Building { ~ }
}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li>We then create <code>moveBuilding()</code>, to drag building around, we can do so, by ray-casting(<code>getRaycast()</code>) and get hit location and update building location each frame, we will floor the hit location for grid-snapping effect and set building's z-axis location to 0 as we don't want building to be higher or lower.</li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<h3 id="placingandremoving">PLACING AND REMOVING</h3>
<p>To be able to place building, we will first unselect any selected building, spawn new building and set selected building to new spawned one. To place it we will simply unselect our selected building. To remove building, we will select the building, than remove the building and then unselect building.</p>
<!-- tabs:start -->
<h4 id="buildingcontrollerhx-2"><strong>BuildingController.hx</strong></h4>
<pre><code class="haxe language-haxe">import iron.object.Object;
~
typedef Building = { ~ }

class BuildingController extends iron.Trait {
    ~
    //Declare arrays of buildings
    public static var buildings: Array&lt;Building&gt; = [];
    //Building's Id, eg: bld_hs1, bld_pw2, etc.
    public static var buildingId = 0;

    public function new() { ~ }
    public static function raySelectBuilding() { ~ }
    public static function moveBuilding() { ~ }

    public static function selectBuilding(name: String) {
        selectedBuilding = getBuildingFromString(name);
        isBuildingSelected = true;
        buildingMove = true;
    }

    public static function unselectBuilding() {
        selectedBuilding = null;
        isBuildingSelected = false;
        buildingMove = false;
    }

    public static function spawnBuilding(type: Int) {
        unselectBuilding();
        //Spawn object with name = "bld_"+type
        Scene.active.spawnObject("bld_"+type, null, function(bld: Object){
            //Increment buildingID
            buildingId++;
            //Change name
            bld.name = "bld_"+type+"_"+buildingId;
            //Add new building to add with name and type
            buildings.push({
                name: "bld_"+type+"_"+buildingId,
                type: type
            });
            selectBuilding(bld.name);
        });
    }

    public static function removeBuilding() {
        //Remove Selected building
        Scene.active.getChild(selectedBuilding.name).remove();
        //Remove selected building from buildings array
        removefromArray(selectedBuilding.name, buildings);
        //Unselect building
        unselectBuilding();
    }

    static function getRaycast(group:Int){ ~ }
    static function getBuildingFromString(name: String):Building { ~ }

    static function removefromArray(name: String, buildings: Array&lt;Building&gt;){
        //Define building and set it to null
        var building:Building = null;
        //loop through buildings array
        for (i in buildings){
            //if building's name match, with name parameter
            if (i.name == name){
                //Set above declared building to this
                building = i;
            }
        }
        //Get index of building in buildings array
        var index = buildings.indexOf(building);
        //If it exist(doesn't exist = -1)
        if (index &gt; -1){
            //remove building from array from index and length
            buildings.splice(index, 1);
        }
    }
}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li><p>We creates <code>selectBuilding(*name*)</code> and we do so by setting selectedBuilding to <em>name</em>, isBuildingSelected to true, and buildingMove to true.</p></li>
<li><p>We creates <code>unselectBuilding()</code> and we do so by setting selectedBuilding, isBuildingSelected to null, false respectively.</p></li>
<li><p>We will now spawn building with <code>spawnBuilding(*type*)</code>, we will first spawn object and when it is spawned, we will increment buildingId, set it name to "bld_"+its type+ its buildingId, pushes this building to our buildings array and unselect any selected building and select this spawned building.</p></li>
<li><p>We will create a utility function <code>removefromArray(*name*, *buildings*)</code> to remove selectedBuilding from buildings array. we will loop through buildings array check if name matches, if it do then get index of this building in buildings array and then remove it with splice.</p></li>
<li><p>Now to remove building, we will create <code>removeBuilding()</code>, with it we will remove building object from game and then remove it from out buildings array and finally unselect building.</p></li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<h3 id="rotatingandoncontact">ROTATING AND ON-CONTACT</h3>
<p>We will get contact between buildings to avoid putting them inside of each other. And also add rotation, because buildings can faced any side!.</p>
<!-- tabs:start -->
<h4 id="buildingcontrollerhx-3"><strong>BuildingController.hx</strong></h4>
<pre><code class="haxe language-haxe">import armory.trait.physics.RigidBody;
~
typedef Building = { ~ }

class BuildingController extends iron.Trait {
    ~
    //Is building in any contact
    public static var buildingInContact = false;

    public static function new() { ~ }
    public static function raySelectBuilding() { ~ }
    public static function moveBuilding() { ~ }
    public static function selectBuilding(name: String) { ~ }
    public static function unselectBuilding() { ~ }
    public static function spawnBuilding(type: String) { ~ }
    public static function removeBuilding() { ~ }

    public static function buildingContact() {
        var physics = PhysicsWorld.active;
        //Get contact of selected building
        var contact = physics.getContacts(Scene.active.getChild(selectedBuilding.name).getTrait(RigidBody));
        if (contact != null){
            buildingInContact = true;
        }else{
            buildingInContact = false;
        }
    }

    public static function rotateBuilding() {
        Scene.active.getChild(selectedBuilding.name).transform.rotate(Vec4.zAxis(), 1.57);
    }

    static function getRaycast(group:Int){ ~ }
    static function getBuildingFromString(name: String):Building { ~ }
    static function removefromArray(name: String, buildings: Array&lt;Buildings&gt;){ ~ }
}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li><p>To get contact of our buildings with any object that is rigidbody, we do so by creating <code>buildingContact()</code>, we get physics object that is in contact with our building's rigidbody, if there is any rigidbody contacting with our building, set buildingInContact to true, else false.</p></li>
<li><p>For last feature i.e. rotating, we will create <code>rotateBuilding()</code>, and rotate the building on z-axis by 1.57 in radians(90 degrees) every time this function is called.</p></li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<h2 id="player">PLAYER</h2>
<h3 id="handlingbuildingscontroller">HANDLING BUILDINGS CONTROLLER</h3>
<p>We will need to let player control the buildings, such as moving, removing, etc.</p>
<ol>
<li>Create new Haxe trait <code>PlayerController</code>, we will use it as player interaction with game.</li>
</ol>
<!-- tabs:start -->
<h4 id="playercontrollerhx"><strong>PlayerController.hx</strong></h4>
<pre><code class="haxe language-haxe">import iron.system.Input;

//Import previously made BuildingController
import arm.BuildingController;

class PlayerController extends iron.Trait {

    var mouse = Input.getMouse();
    var kb = Input.getKeyboard();

    var building = BuildingController;
    var buildingType: Int = 1;

    public function new() {
        super();
        notifyOnUpdate(update);
    }

    function update() {
        if(!building.isBuildingSelected){
            if (mouse.started()){ //mouse.started() defaults to "left" if no button is provided.
                building.raySelectBuilding();
            }
            if (kb.started("p")){
                building.spawnBuilding(buildingType);
            }
        }else{
            if (mouse.started("right")) {
                if (!building.buildingInContact){
                    building.unselectBuilding();
                }
            }
            if (kb.started("m")){
                building.buildingMove = true;
            }else if (kb.started("f")){
                building.removeBuilding();
            }else if (kb.started("r")){
                building.rotateBuilding();
            }
        }

        if (building.buildingMove) {
            building.moveBuilding();
            building.buildingContact();
        }

        if (kb.started("1")) buildingType = 1;
        else if (kb.started("2")) buildingType = 2;
        else if (kb.started("3")) buildingType = 3;
        else if (kb.started("4")) buildingType = 4;
        else if (kb.started("5")) buildingType = 5;
        else if (kb.started("6")) buildingType = 6;
        else if (kb.started("7")) buildingType = 7;
        else if (kb.started("8")) buildingType = 8;
    }
}
</code></pre>
<hr />
<p><details>
    <summary>Code explanation</summary></p>
<ol>
<li><p>First we initialize some variables.</p></li>
<li><p>Call update function every frame.</p></li>
<li><p>Check if any building isn't selected, if not, then press left mouse button to select building and press <code>p</code> to spawn buildings. else if any building is selected, continuously check its contacts, if right mouse button is pressed than check if it is in any contact, if not then unselect building. If key button <code>m</code>, <code>f</code>, <code>r</code> is pressed, then move, remove, rotate building respectively.</p></li>
<li><p>Use number key button to select building type.
</details></p></li>
</ol>
<hr />
<!-- tabs:end -->
<p>Putting it all together you should get:</p>
<p><img src="/../../../docassets/CBS_1_F.gif" alt="" title=":size=400" /></p>
<p>Now try creating more building such as gardens, parks, sawmills, etc and apply same physics as <code>bld_hs</code>, and replace cube buildings, with your own assets.</p>
<p><strong>ðŸŽ‰There we go! CBS's Basic part is over!ðŸŽ‰</strong></p>
<hr />
<p>If you have any problem then you can check the source code at <a href="https://github.com/BlackGoku36/CBST-A3D">CBST-A3D</a></p>
<hr />
<p>!&gt; W.I.P</p>
        </div>
    </div>
    <nav aria-label="Page navigation example">
        <ul class="pagination justify-content-center">
            <li class="page-item disabled">
                <a class="page-link disabled" href="#" tabindex="-1" aria-disabled="true">Previous</a>
            </li>
            <li class="page-item"><a class="page-link active " href="Basics.html">1</a></li>
            <li class="page-item"><a class="page-link a" href="Resources.html">2</a></li>
            <li class="page-item"><a class="page-link a" href="UI.html">3</a></li>
            <li class="page-item">
                <a class="page-link a" href="Resources.html">Next</a>
            </li>
        </ul>
    </nav>
    <script src="../../../main2.js"></script>
    <script>create("../../../")</script>
</body>
</html>