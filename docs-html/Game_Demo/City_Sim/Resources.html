<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../doc.css">
    <link rel="stylesheet" href="../../../atom-one-dark.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title>CBS | Resources</title>
</head>
<body class="purple-grey">
    <div id="sidebar" class="sidebar">
        <script src="../sidebar.js"></script>
    </div>
    <div id="main">
        <script src="../../../main1.js"></script>
        <script>main("Resources");</script>
        <p>In <code>Resources</code>, we will involve resource producing and collecting from buildings.</p>
<p>Rechecking our concept, when we place buildings, we want it to produce some resources at cost of some other resources, here the small table from the concept:</p>
<table>
<thead>
<tr>
<th>Buildings</th>
<th>Costs</th>
<th>Produce</th>
</tr>
</thead>
<tbody>
<tr>
<td>House</td>
<td>Woods, Stones, Electricity</td>
<td>Money, Happiness</td>
</tr>
<tr>
<td>Parks</td>
<td>Woods, Stones, Electricity</td>
<td>Money, Happiness</td>
</tr>
<tr>
<td>Sawmills</td>
<td>Money, Electricity</td>
<td>Woods, Pollution</td>
</tr>
<tr>
<td>Quarry</td>
<td>Money, Electricity</td>
<td>Stones, Pollution</td>
</tr>
<tr>
<td>Powerplants</td>
<td>Money</td>
<td>Electricity, Pollution</td>
</tr>
</tbody>
</table>
<hr />
<p>Table of contents:</p>
<ul>
<li><p><strong>RESOURCES</strong></p>
<ul>
<li><a href="docs/Game_Demo/City_Sim/Resources#building-properties-structure">Building properties structure</a></li>
<li><a href="docs/Game_Demo/City_Sim/Resources#recalculate-buildings">Recalculate buildings</a></li>
<li><a href="docs/Game_Demo/City_Sim/Resources#recalculate-resources">Recalculate resources</a></li>
<li><a href="docs/Game_Demo/City_Sim/Resources#producing-resources">Producing resources</a></li></ul></li>
<li><p><a href="docs/Game_Demo/City_Sim/Resources#canvas">Canvas</a></p></li>
</ul>
<hr />
<h2 id="resources-1">RESOURCES</h2>
<p>Buildings will produce given amount of resources in given interval of time. We want to make:</p>
<ul>
<li>House produce 5 money every 5 sec at cost of 10 woods and 10 stones.</li>
<li>Sawmill produce 5 woods every 5 sec at cost of 10 money.</li>
<li>Quarry produce 5 stones every 5 sec at cost of 10 money.</li>
<li>Powerplant produce 10 electricity every 5 sec at cost of 20 money.</li>
<li>Electricity to be used by house, sawmill, quarry to produce their resources, if they don't get enough electricity, they stop production.</li>
</ul>
<p><em>(values are not absolute, it needed to be tweak for final game)</em></p>
<h4 id="buildingpropertiesstructure">BUILDING PROPERTIES STRUCTURE</h4>
<p>Let create proper structure of our building property, where we will store buildings properties such as maximum buildings allowed, cost, production, etc.</p>
<ol>
<li>Create new scene Haxe trait <code>WorldController</code>, this will act as our main world controller.</li>
</ol>
<!-- tabs:start -->
<pre><code class="haxe language-haxe">// WorldController.hx
    
package arm;
//Building properties structure
typedef BuildingProp = {
    //at: how many building are there currently?, max: how many maximum buildings can be spawned?
    at:Int, max:Int,
    //Cost amount of money, wood, stones, electricity
    costM:Int, costW:Int, costS:Int, costE:Int,
    //Produce amount of money, woods, stones, electricity
    prodM: Int, prodW:Int, prodS:Int, prodE:Int,
    //Produce amount of happiness, pollution
    prodH:Int, prodP:Int,
    //Timetask id
    tt: Int
}

class WorldController extends iron.Trait {
    //Set houses prop
    public static var houseProp: BuildingProp = {
        at:0, max:2, costM: 0,costW:10, costS:10, costE:5, prodM: 5, prodW:0, prodS:0, prodE: 0, prodH:3, prodP:0, tt: 0
    };
    //Set parks prop
    public static var parkProp: BuildingProp = {
        at:0, max:2, costM: 0,costW:10, costS:10, costE:5, prodM: 5, prodW:0, prodS:0, prodE: 0, prodH:5, prodP:0, tt: 0
    };
    //Set sawmills prop
    public static var sawmillProp: BuildingProp = {
        at:0, max:2, costM: 10,costW:0, costS:0, costE:5, prodM: 0, prodW:5, prodS:0, prodE: 0, prodH:0, prodP:3, tt: 0
    };
    //Set quarrys prop
    public static var quarryProp: BuildingProp = {
        at:0, max:2, costM: 10, costW:0, costS:0, costE:5, prodM: 0, prodW:0, prodS:5, prodE: 0, prodH:0, prodP:3, tt: 0
    };
    //Set powerplants prop
    public static var powerplantProp: BuildingProp = {
        at:0, max:2, costM: 20, costW:0, costS:0, costE:0, prodM: 0, prodW:0, prodS:0, prodE: 10, prodH:0, prodP:5, tt: 0
    };

    public function new() {
        super();
    }
}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li><p>We create buildings properties structure to store information and fields which are not needed are set to '0' as we don't want to create structure for each building.</p></li>
<li><p>We set properties of buildings <code>houseProp</code>, <code>parkProp</code>, etc.</p></li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<h4 id="recalculatebuildings">RECALCULATE BUILDINGS</h4>
<p>We will recalculate buildings from buildings structure and set building properties structure and limit amount of particular buildings that can be spawned.</p>
<!-- tabs:start -->
<pre><code class="haxe language-haxe">// BuildingController.hx
    
~
import arm.WorldController;

typedef Building = {~}
class BuildingController extends iron.Trait{
    ~
    public static var enoughBuildings = true;
    public function new(){~}
    ~
    public static function spawnBuilding(type: Int){
        var world = WorldController;
        //Check if this type of buildings reached max amount
        checkMaxBuilding(type);
        //If there is not enough building
        if(!enoughBuildings){
            Scene.active.spawnObject("bld_"+type, null, function(bld: Object){
                ~
                buildings.push({~});
                //Recalculate amount of buildings
                recalculateBuildings();
                unselectBuilding();
                selectBuilding(bld.name);
            });
        }

    }
    public static function removeBuilding(){
        Scene.active.getChild(selectedBuilding).remove();
        removefromArray(selectedBuilding, buildings);
        //Recalculate amount of buildings
        recalculateBuildings();
        unselectBuilding();
    }
    ~
    static function recalculateBuildings(){
        var world = WorldController;
        //Create buildings type list
        //[House, parks,......, powerplant]
        var buildingList = [0, 0, 0, 0, 0, 0, 0, 0];
        for(building in buildings){
            switch (building.type){
                //Set increase building list by one of certain type
                case 1: buildingList[0] += 1;//House
                case 2: buildingList[1] += 1;//Park
                case 5: buildingList[4] += 1;//Sawmill
                case 6: buildingList[5] += 1;//Quarry
                case 8: buildingList[7] += 1;//Powerplant
            }
        }
        //Set 'at' of building property
        world.houseProp.at = buildingList[0];
        world.parkProp.at = buildingList[1];
        world.sawmillProp.at = buildingList[4];
        world.quarryProp.at = buildingList[5];
        world.powerplantProp.at = buildingList[7];
    }
    static function checkMaxBuilding(type:Int){
        var world = WorldController;
        switch(type){
            //Check if building of type reached max amount, then set enough buildings to true else false
            case 1: world.houseProp.at == world.houseProp.max ? enoughBuildings = true : enoughBuildings = false;
            case 2: world.parkProp.at == world.parkProp.max ? enoughBuildings = true : enoughBuildings = false;
            case 5: world.sawmillProp.at == world.sawmillProp.max ? enoughBuildings = true : enoughBuildings = false;
            case 6: world.quarryProp.at == world.quarryProp.max ? enoughBuildings = true : enoughBuildings = false;
            case 8: world.powerplantProp.at == world.powerplantProp.max ? enoughBuildings = true : enoughBuildings = false;
        }
    }
}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li><p>In <code>recalculateBuildings()</code>, we create array of building list, each index represent building type. Then we loop through our array of buildings and switch through building types and increase the building list by one if type matches. And finally set 'at' of our buildings property from building list.</p></li>
<li><p>In <code>checkMaxBuilding(*type*)</code>, we switch through types, if type match we check building of type's property and check if no. of buildings is same as maximum limit, if true than set enoughBuildings to true, else false.</p></li>
<li><p>In <code>spawnBuilding(*type*)</code>, check if maximum amount of buildings of particular type reached, if not true than allow to spawn, and then on spawning recalculate buildings again.</p></li>
<li><p>In <code>removeBuilding()</code>, recalculate buildings again after selected building is removed.</p></li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<h4 id="recalculateresources">RECALCULATE RESOURCES</h4>
<p>We will recalculate resources after we spawn the building, i.e., after spawning we subtract the building's resource cost from total resources. And we will also limit buildings from being spawned if total resource is less than building's resource cost.</p>
<!-- tabs:start -->
<pre><code class="haxe language-haxe">// WorldController.hx
    
~
typedef BuildingProp = {~}

class WorldController extends iron.Trait {
    //Set resources with array -&gt; [at, max]
    public static var happiness:Array&lt;Int&gt; = [50, 100];
    public static var money:Array&lt;Int&gt; = [50, 100];
    public static var woods:Array&lt;Int&gt; = [50, 100];
    public static var stones:Array&lt;Int&gt; = [50, 100];
    public static var electricity:Array&lt;Int&gt; = [0, 100];

    public static var houseProp: BuildingProp = {~};
    public static var parkProp: BuildingProp = {~};
    public static var sawmillProp: BuildingProp = {~};
    public static var quarryProp: BuildingProp = {~};
    public static var powerplantProp: BuildingProp = {~};

    public function new(){~}

}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li>We set resources with array as [amount of this resource, maximum resource storeable].</li>
</ol>
<p></details></p>
<hr />
<pre><code class="haxe language-haxe">// BuildingController.hx
    
~
typedef Building = {~}
class BuildingController extends iron.Trait{
    ~
    public static var enoughBuildings = true;
    public static var enoughResources = true;
    public function new(){~}
    ~
    public static function spawnBuilding(type: Int){
        var world = WorldController;
        checkMaxBuilding(type);
        //Check if resources reached max amount
        checkResources(type);
        //If there is not enough building and there is enough resource
        if(!enoughBuildings &amp;&amp; enoughResources){
            Scene.active.spawnObject("bld_"+type, null, function(bld: Object){
                ~
                buildings.push({~});
                recalculateBuildings();
                //Recalculate amount of resources of this type
                recalculateResources(type);
                unselectBuilding();
                selectBuilding(bld.name);
            });
        }
    }
    public static function removeBuilding(){~}
    ~
    static function recalculateBuildings(){~}
    static function checkResources(type:Int){
        var world = WorldController;
        switch(type){
            case 1: (world.woods[0] &lt; world.houseProp.costW &amp;&amp; world.stones[0] &lt; world.houseProp.costS) ? enoughResources = false : enoughResources = true;
            case 5: (world.money[0] &lt; world.sawmillProp.costM) ? enoughResources = false : enoughResources = true;
            case 6: (world.money[0] &lt; world.quarryProp.costM) ? enoughResources = false : enoughResources = true;
            case 8: (world.money[0] &lt; world.powerplantProp.costM) ? enoughResources = false : enoughResources = true;
        }
    }
    static function recalculateResources(type:Int) {
        var world = WorldController;
        switch(type){
            case 1:
                world.woods[0] -= world.houseProp.costW;
                world.stones[0] -= world.houseProp.costS;
            case 5:
                world.money[0] -= world.sawmillProp.costM;
            case 6:
                world.money[0] -= world.quarryProp.costM;
            case 8:
                world.money[0] -= world.powerplantProp.costM;
        }
    }
    static function checkMaxBuilding(type:Int){~}
}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li>In <code>recalculateResources(*type*)</code>, We recalculate resources by subtracting cost from resources amount with given type.</li>
<li>In <code>checkResources(*type*)</code>, we check if resources available is less than the cost, if so, then we set enoughResources to true else false.</li>
<li>We check resources before spawning, if there is enough resources and not enough building then we spawn the building, when spawned we recalculate the resources.</li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<h4 id="producingresources">PRODUCING RESOURCES</h4>
<p>Now, we want buildings to produce resources at given interval. This can be simply done by using kha's Scheduler timetask.</p>
<!-- tabs:start -->
<pre><code class="haxe language-haxe">// WorldController.hx
    
package arm;

import kha.Scheduler;

import arm.BuildingController;
import arm.MainCanvasController;

typedef BuildingProp = {~}

class WorldController extends iron.Trait {

    public static var money:Array&lt;Int&gt; = [50, 100];
    ~
    public static var electricity:Array&lt;Int&gt; = [0, 100];

    public static var houseProp: BuildingProp = {~};
    ~
    public static var powerplantProp: BuildingProp = {~};

    public function new() {
        super();
        notifyOnInit(init);
    }

    function init() {
        var world = WorldController;
        //Add timetask with interval of 5sec and assign timetask id to housett.
        houseProp.tt = Scheduler.addTimeTask(function(){
            //check electricity, if electricity is greater than cost and money amount is less than max money
            if (electricity[0] &gt;= world.houseProp.costE &amp;&amp; money[0] &lt; money[1]){
                // increase by (no.of houses x house money production.)
                money[0] += houseProp.at * houseProp.prodM;
                //Do clamping and handle overflowing
                if (money[0] &gt; money[1]) money[0] = money[1];
                //Multiply no. of houses * houses cost and subtract the product from electricity amount
                electricity[0] -= houseProp.at * houseProp.costE;
            }
        }, 5, 5);
        parkProp.tt = Scheduler.addTimeTask(function(){
            if (electricity[0] &gt;= world.parkProp.costE &amp;&amp; money[0] &lt; money[1]){
                money[0] += parkProp.at * parkProp.prodM;
                if (money[0] &gt; money[1]) money[0] = money[1];
                electricity[0] -= parkProp.at * parkProp.costE;
            }
        }, 5, 5);
        sawmillProp.tt = Scheduler.addTimeTask(function(){
            if (electricity[0] &gt;= world.sawmillProp.costE &amp;&amp; woods[0] &lt; woods[1]){
                woods[0] += sawmillProp.at * sawmillProp.prodW;
                if (woods[0] &gt; woods[1]) woods[0] = woods[1];
                electricity[0] -= sawmillProp.at * sawmillProp.costE;
            }
        }, 5, 5);
        quarryProp.tt = Scheduler.addTimeTask(function(){
            if (electricity[0] &gt;= world.quarryProp.costE &amp;&amp; stones[0] &lt; stones[1]){
                stones[0] += quarryProp.at * quarryProp.prodS;
                if (stones[0] &gt; stones[1]) stones[0] = stones[1];
                electricity[0] -= quarryProp.at * quarryProp.costE;
            }
        }, 5, 5);
        powerplantProp.tt = Scheduler.addTimeTask(function(){
            if(electricity[0] &lt;= electricity[1]) electricity[0] += powerplantProp.at * powerplantProp.prodE;
        }, 5, 5);
    }
}
</code></pre>
<hr />
<p><details>
    <summary>Code Explanation</summary></p>
<ol>
<li>We create timetask for each building type, this is done by <code>kha.Scheduler.addTimeTask(*func*, *start*, *period*, *duration*)</code>, where <code>func</code> is function done in this time task, <code>start</code> is time to wait for first <code>func</code> execution, <code>period</code> is time interval between <code>func</code> execution, <code>duration</code>, is total amount of time this time task exist for, '0' means infinite amount of time and is set defaultly.</li>
<li>We than check if there is sufficient electricity, than check if the resource is less than max, if so than let it produce the resource. Then we will check if resource is more than max resource if so, than set resource as max resources(This works as clamping and to prevent money overflowing).Then multiply no. of building by building's electricity cost and subtract the product from electricity amount.</li>
</ol>
<p></details></p>
<hr />
<!-- tabs:end -->
<h2 id="canvas">CANVAS</h2>
<p>We will use <code>Canvas</code> to display our resources with progress bars.</p>
<ol>
<li>Create new canvas <code>MainCanvas</code> and uncheck it, we will use this as our main canvas, we will have other UI such as menus in here.</li>
</ol>
<p>In <code>MainCanvas</code>, create:</p>
<ol>
<li><p><code>Text</code> element:</p>
<ol>
<li><code>Name</code>: money. <code>Text</code>: Money</li>
<li><code>Name</code>: wood. <code>Text</code>: Wood</li>
<li><code>Name</code>: stone. <code>Text</code>: Stone</li>
<li><code>Name</code>: electricity. <code>Text</code>: Electricity</li>
<li><code>Name</code>: money-amt, wood-amt, stone-amt, electricity-amt. <code>Text</code>: 0/100</li></ol></li>
<li><p><code>RectPB</code> element:</p>
<ol>
<li><code>Name</code>: moneypb, woodpb, stonepb, electricitypb. <code>Progress</code>: 0. <code>Total progress</code>: 100</li></ol></li>
</ol>
<p><img src="../../../docassets/CBS_2_1.png" alt="" width="70%" height="70%" /></p>
<hr />
<p>On to the script, to control the amount and progress bars.</p>
<ol>
<li>Create new Haxe trait <code>MainCanvasController</code></li>
</ol>
<!-- tabs:start -->
<pre><code class="haxe language-haxe">// MainCanvasController.hx
    
package arm;

import armory.trait.internal.CanvasScript;
import iron.Scene;
import arm.WorldController;

class MainCanvasController extends iron.Trait {

    static var maincanvas:CanvasScript;
    var world = WorldController;

    public function new() {
        super();
        notifyOnInit(function() {
            //Set canvas on init
            maincanvas = new CanvasScript("MainCanvas", "Big_shoulders_text.ttf");
            maincanvas.setCanvasVisibility(true);
        });
        notifyOnUpdate(updateCanvas);
    }

    function updateCanvas() {
        //Update PB and Amount
        updatePB();
        updateAmount();
    }
    function updatePB() {
        //Set progress bar elements's 'at' and 'total'
        maincanvas.getElement("moneypb").progress_total = world.money[1];
        maincanvas.getElement("moneypb").progress_at = world.money[0];
        maincanvas.getElement("woodpb").progress_total = world.woods[1];
        maincanvas.getElement("woodpb").progress_at = world.woods[0];
        maincanvas.getElement("stonepb").progress_total = world.stones[1];
        maincanvas.getElement("stonepb").progress_at = world.stones[0];
        maincanvas.getElement("electricitypb").progress_total = world.electricity[1];
        maincanvas.getElement("electricitypb").progress_at = world.electricity[0];
    }
    function updateAmount() {
        //Set amount text element's text to 'resource/totalresource'
        maincanvas.getElement("money-amt").text = world.money[0] + "/" + world.money[1];
        maincanvas.getElement("wood-amt").text = world.woods[0] + "/" + world.woods[1];
        maincanvas.getElement("stone-amt").text = world.stones[0] + "/" + world.stones[1];
        maincanvas.getElement("electricity-amt").text = world.electricity[0] + "/" + world.electricity[1];
    }
}
</code></pre>
<hr />
<p><details>
    <summary><strike>Code Explanation</strike></summary></p>
<p><em>(Nothing to explain here as code say itself)</em>
</details></p>
<hr />
<!-- tabs:end -->
<p>Putting it all together and you should get something like this:</p>
<p><img src="../../../docassets/CBS_2_2.gif" alt="" width="70%" height="70%" /></p>
<p><strong>🎉 And We did it! We completed resources part! 🎉</strong></p>
<hr />
<p>If you have any problem then you can check the source code at <a href="https://github.com/BlackGoku36/CBST-A3D">CBST-A3D</a></p>

        </div>
    </div>
    <nav aria-label="Page navigation example">
        <ul class="pagination justify-content-center">
            <li class="page-item">
                <a class="page-link a" href="Basics.html" tabindex="-1" aria-disabled="true">Previous</a>
            </li>
            <li class="page-item"><a class="page-link a " href="Basics.html">1</a></li>
            <li class="page-item"><a class="page-link active" href="Resources.html">2</a></li>
            <li class="page-item"><a class="page-link a" href="UI.html">3</a></li>
            <li class="page-item">
                <a class="page-link a" href="UI.html">Next</a>
            </li>
        </ul>
    </nav>
    <script src="../../../main2.js"></script>
    <script>create("../../../")</script>
</body>
</html>